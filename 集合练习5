package com.homework;

import java.util.TreeSet;

@SuppressWarnings({"all"})
public class Homework05 {
    public static void main(String[] args) {
        TreeSet treeSet = new TreeSet();
        //分析源码
        //add 方法，因为 TreeSet() 构造器没有传入Comparator接口的匿名内部类
        //所以在底层会去调用你传入对象的Comparable接口的compareTo方法 但是Person类并没有实现Comparable接口
        //因此，会尝试把一个Person转成(Comparable<? super K>)所有会报类型转换异常ClassCastException.
        // Comparable<? super K> k = (Comparable<? super K>) key;

        treeSet.add(new Person());//ClassCastException.
        treeSet.add(new Person());//ClassCastException.
        treeSet.add(new Person());//ClassCastException.
        treeSet.add(new Person());//ClassCastException.
        treeSet.add(new Person());//ClassCastException.

        System.out.println(treeSet);
        //看源码
        /*
            public V put(K key, V value) {
                Entry<K,V> t = root;
                if (t == null) {
                    compare(key, key); // type (and possibly null) check

                    root = new Entry<>(key, value, null);
                    size = 1;
                    modCount++;
                    return null;
                }
                int cmp;
                Entry<K,V> parent;
                // split comparator and comparable paths
                Comparator<? super K> cpr = comparator;//如果没有传入匿名对象那么此时comparator为null所以会不会进入下面的if语句
                if (cpr != null) {
                    do {
                        parent = t;
                        cmp = cpr.compare(key, t.key);
                        if (cmp < 0)
                            t = t.left;
                        else if (cmp > 0)
                            t = t.right;
                        else
                            return t.setValue(value);
                    } while (t != null);
                }
                else {
                    if (key == null)
                        throw new NullPointerException();
                    @SuppressWarnings("unchecked")
                        Comparable<? super K> k = (Comparable<? super K>) key;//会直接执行到这里来 会根据你传入进来的对象尝试将他转成Comparable这个类型，如果传入的对象没有实现改接口那么就报类型转换异常
                    do {
                        parent = t;
                        cmp = k.compareTo(t.key);
                        if (cmp < 0)
                            t = t.left;
                        else if (cmp > 0)
                            t = t.right;
                        else
                            return t.setValue(value);
                    } while (t != null);
                }
                Entry<K,V> e = new Entry<>(key, value, parent);
                if (cmp < 0)
                    parent.left = e;
                else
                    parent.right = e;
                fixAfterInsertion(e);
                size++;
                modCount++;
                return null;
            }
         */
    }
}

class Person implements Comparable{
    //如果想不报错那么就需要让Person类去实现Comparable接口
    //因为我们写的时return 0 因此只能加入一个，如果加入多个会加入不进去，因为返回0就是不加入

    @Override
    public int compareTo(Object o) {
        return 0;
    }
}
