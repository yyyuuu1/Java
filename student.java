package idea.chapter08.extends_;

/**
 * 子类
 */
//9.子类最多只能继承一个父类(指直接继承)，即java中是单继承机制。 如果在想去继承其他的类是不可以的
//  现在有 A B C 三个类  此时C已经继承了B 如果还想使用 A中的属性和方法，那么B在继承A 这样就可以了
public class student extends teacher {

    //10.不能滥用继承，子类和父类之间必须满足is-a的逻辑关系
    //比如 Person -> dog  人和我们的狗没有关系，因此这样不合理
    //Animal —> Dog 这样就合理了，因为动物里包含狗

    //7.java所有类都是Object类的子类，Object是所有类的基类.
    //8.父类构造器的调用不限于直接父类！将一直往上追溯直到Object类(顶级父类)
    /*
    这两句话怎么理解，我们现在类继承的关系是student 继承了teacher 实际上在teacher上还有一个父类，就是Object Object是所以类的父类
    因此我们目前类继承的关系就是 student -> teacher -> Object
     */


    public student() {
        //2.子类必须调用父类的构造器，完成父类的初始化

        //怎么样去理解这句话
        //在这里有一个小细节，即使我们这里什么都没有写，但是其实默认就会带一句这样的话super();
        //super();//这句话是默认存在的  意思就是当使用子类去创建一个实例对象的时候，那么会自动的去调用父类的无参构造器，因此就单纯创建了一个对象，最后输出的结果会是先调用父类的构造器，然后在是子类的

        //4.如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)
        super("jack", 1);
        System.out.println("子类的无参构造器被调用");

    }

    //子类的带一个参数的构造器
    public student(String name) {
        //3.当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，
        // 则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过

        //这里我们把父类的无参构造器给注释掉了，因为在子类创建对象的时候，默认情况下总会去调用父类的无参构造器，但是因为父类的无参构造器被注释调了，
        //因此我们需要手动的指定去调用那个构造器否则就会报错
        //super();//这就是去调用父类的无参构造器
        super("jack", 1);//这就是去调用父类带两个参数的构造器
        System.out.println("子类的student(String name)构造器被调用");
    }

    //子类的带两个参数的构造器
    public student(String name, int age) {
        //5.super在使用时，必须放在构造器第一行(super只能在构造器中使用)
        //6.super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器
        //this();//就不可以在使用了
        super("jack");
        System.out.println("子类的student(String name,int age)构造器被调用");
        //super("jack");//这样是错误的，super()要写在父类构造器中的第一行
    }

    //1.子类继承了所有的属性和方法。非私有的属性和方法可以在子类中直接访问，但私有属性和方法不能在子类直接访问，要通过公共的方法去访问
    public void say() {
        //这里直接输出父类的属性
        System.out.println(n1);
        System.out.println(n2);
        System.out.println(n3);
        //我们可以看到，因为n4是private修饰的，因此不能够直接访问，如果直接访问就会报错
        //那么我们我应该怎么样去访问私有的属性呢，需要父类提供一个公共的方法
        System.out.println(getN4());//这样就可以了
        //System.out.println(n4);

        //方法也一样，私有的方法也调用不了
        test100();
        test200();
        test300();
        //这样写就会报错 如果想要调用父类的私有方法，那么需要父类提供一个公共的方法
        hi();//该方法是public因此在子类中可以直接调用，hi()方法中，调用了父类的私有方法，因此我们这里调用hi()方法，就可以访问到父类的私有方法
        //test400();
    }


}
