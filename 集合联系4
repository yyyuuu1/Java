package com.homework;

public class Homework04 {
    public static void main(String[] args) {
        //HashSet实现去重是因为 在底层会根据你传入的key计算一个hash值，
        //会先计算一个你在table表中存放的位置 ，如果该位置还没有其他元素添加则直接加入
        //如果已经有了会先进行判断，如果你的加入的对象的hash值和当前位置的hash值相同
        //或者是同一个对象，或者是他们的equals相同就不进行添加
        //并且底层还会判断当前是不是红黑树，如果是就按照红黑树的方法进行
        //如果是一个链表 就依次循化遍历，期间如果发现相同的就直接break，如果没有发现相同的就直接加入到链表的最后一个位置


        //TreeSet去重机制：如果我们传入了comparator匿名对象，那么底层会使用compare方法进行比较
        //如果返回0就不会加入
        //如果没有传入对象，直接使用默认的那么会调用
        // Comparable<? super K> k = (Comparable<? super K>) key;
        //就是以你添加的对象实现的Comparable接口的compareTo去重.如果返回0也加入不成功
        //举例
        //如果我们没有传入对象，并且传入的类型还是一个String类型那么在执行到Comparable<? super K> k = (Comparable<? super K>) key;这句话时
        //会动态绑定到String的compareTo方法因为String实现了Comparable这个接口

        //看源码
        /*
            public V put(K key, V value) {
                Entry<K,V> t = root;
                if (t == null) {
                    compare(key, key); // type (and possibly null) check

                    root = new Entry<>(key, value, null);
                    size = 1;
                    modCount++;
                    return null;
                }
                int cmp;
                Entry<K,V> parent;
                // split comparator and comparable paths
                Comparator<? super K> cpr = comparator;
                if (cpr != null) {
                    do {
                        parent = t;
                        cmp = cpr.compare(key, t.key);
                        if (cmp < 0)
                            t = t.left;
                        else if (cmp > 0)
                            t = t.right;
                        else
                            return t.setValue(value);
                    } while (t != null);
                }
                else {
                    if (key == null)
                        throw new NullPointerException();
                    @SuppressWarnings("unchecked")
                        Comparable<? super K> k = (Comparable<? super K>) key;
                    do {
                        parent = t;
                        cmp = k.compareTo(t.key);
                        if (cmp < 0)
                            t = t.left;
                        else if (cmp > 0)
                            t = t.right;
                        else
                            return t.setValue(value);
                    } while (t != null);
                }
                Entry<K,V> e = new Entry<>(key, value, parent);
                if (cmp < 0)
                    parent.left = e;
                else
                    parent.right = e;
                fixAfterInsertion(e);
                size++;
                modCount++;
                return null;
            }
         */

    }
}
